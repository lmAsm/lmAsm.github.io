<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mongodb</title>
    <url>/01/12/mangoDB/</url>
    <content><![CDATA[<h2 id="MangoDB"><a href="#MangoDB" class="headerlink" title="MangoDB"></a>MangoDB</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>非关系数据库；文档型数据库</p>
<p>MongoDB的数据模型是面向文档的，所谓文档是一种类似于JSON的i，简单理解<br>MongoDB这个数据库中存的是各种各样的JSON。</p>
<a id="more"></a>

<p>偶数版本为稳定版，奇数版本为开发版。</p>
<p>三个概念：</p>
<ul>
<li><p>数据库</p>
</li>
<li><p>集合 </p>
<p>   类似数组，可以存放文档</p>
</li>
<li><p>文档</p>
<p>   文档数据库中的最小单位，我们存储和操作的内容都是文档</p>
</li>
</ul>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>启动服务器：</p>
<p>​    <strong>mongodb</strong></p>
<pre><code>**mongod** **--dbpath 数据库 --port 123**</code></pre><p>启动客户端：</p>
<p>​    输入 <strong>mongo</strong>  连接<strong>mongodb</strong>，出现 <strong>&gt;</strong></p>
<p>显示当前所有数据库：</p>
<p>​    <strong>show dbs  /  show databases</strong></p>
<p>进入指定数据库：（不存在时自动创建）</p>
<p>​    <strong>use  test</strong></p>
<p>显示当前在哪个数据库中：</p>
<p>​    <strong>db</strong></p>
<p>显示当前数据库中所有的集合：</p>
<p>​    <strong>show collections</strong></p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a><strong>增</strong></h3><p> 向某个集合中插入文档:</p>
<p>​    <strong>db.collection.insert({name:”zhangsan”,age:12,gender:”男”});</strong></p>
<p><strong>插入</strong>多个文档：(数组)</p>
<p>​    <strong>db.collection.insert([</strong></p>
<p>​        <strong>{name:”zhangsan”,age:12,gender:”男”},</strong></p>
<p>​        <strong>{name:”zhangsan”,age:12,gender:”男”},</strong></p>
<p>​        <strong>{name:”zhangsan”,age:12,gender:”女”},</strong></p>
<p>​    <strong>]);</strong></p>
<p><strong>插入</strong>文档的其他方法：</p>
<p>​    <strong>db.collection.insertOne();</strong>     一次只能插入一个文档</p>
<p>​    <strong>db.collection.insertMany();</strong>  一次必须插入多个文档，即数组形式。</p>
<p>  <strong><u>mongodb会自动帮我们添加一个字段：_id，目的就是保证数据的唯一性。我们可以自己指定该字段的值，但是也要保证它的唯一性。</u></strong></p>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p> <strong>查询</strong>文档：</p>
<p>​    *<em>db.collection.find(); *</em>       //查询所有符合条件的文档，返回的是一个数组。</p>
<p>​        find()中可以接收一个对象作为条件参数，{} 表示查询所有的文档，{字段名:字段值}表示查询指定值的文档，如：</p>
<p>​        db.collection.find({age:28})[1];</p>
<p>​        db.collection.find({age:28,name:”张三”});    </p>
<p>​    <strong>db.collection.find({}).count();</strong>   //查询所有结果的数量</p>
<p>​    <strong>db.collection.findOne();</strong>     //查询集合中符合条件的第一个文档，返回的是一个文档对象。</p>
<p>​        db.collection.findOne({name:”张三”}).name;</p>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>   <strong>修改</strong>文档：</p>
<p>​    <strong>db.collection.update(查询条件，新对象)：<u>默认情况会使用新对象来替换旧的对象。默认情况下只会修改第一个。若只想修改指定的字段，需要使用“修改操作符”。</u></strong></p>
<p>​        <strong>db.collection.update({name:”张三”},{age:28});</strong></p>
<p>   修改操作符：</p>
<p>​    <strong>$set:</strong> 修改文档中的指定属性，如：</p>
<p>​        db.collection.update({name:”张三”} , { $set:{</p>
<p>​            address:”郑州市”,</p>
<p>​            gender:”女”</p>
<p>​        }});</p>
<p>​    <strong>$unset:</strong> 删除文档中的指定属性。与$set使用方法相同。</p>
<p>​    <strong>db.collection.updateMany(查询条件，新对象)： 会修改所有的对象。</strong></p>
<p>​    <strong>db.collection.updateOne(查询条件，新对象)： 只会修改一个对象。</strong></p>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>​    <strong>db.collection.remove({});</strong>             //传条件和 find()一样。remove()必须传参。</p>
<p>​        db.collection.remove({age:12 }, true) ;   //第二个参数为true时，只删除一个。    </p>
<p>​    <strong>db.collection.deleteOne();</strong></p>
<p>​    <strong>db.collection.deleteMany();</strong></p>
<p>​    <strong>db.collection.drop();</strong>      //删除集合</p>
<p>​    <strong>db.dropDatabase();</strong>             //删除数据库    </p>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础</title>
    <url>/01/10/docker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><p>​    镜像image：静态、分层存储的文件系统。</p>
<p>​    容器container：运行的实体，可以被创建、启动、停止、删除、暂停等。</p>
<p>​          容器的本质是进程，但有独立的命名空间。</p>
<a id="more"></a>

<p>​          容器在运行时以镜像为基础，创建一个存储层。存储层的生命周期与容器相同，会随着容器删除而丢失。</p>
<p>​          容器的存储层应当保持无状态化，文件写入操作应使用数据卷(volume), 或者绑定宿主目录。</p>
<p>​    仓库注册表registry：集中存储、分发镜像的服务。</p>
<h4 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h4><p>​    1）<strong>docker images</strong> ： 列出本地主机上的镜像</p>
<p>​        docker images|grep tomcat ： 只查询tomcat的镜像</p>
<p>​    2）<strong>docker pull</strong> ：从Docker Hub中拉取或者更新执行镜像</p>
<p>​    3）<strong>docker run ：</strong></p>
<p>​         <strong>-d</strong>  让docker容器在后台运行</p>
<p>​         <strong>-p</strong>  标识通知Docker容器内部使用的网络端口映射到我们使用的主机上</p>
<p>​         <strong>–name</strong>  定义一个do的名字，如果在执行 docker run时没有指定name，那么deamon会自动生成一个随机数字符串当做UUID。</p>
<p>​         <strong>-e</strong>  设置环境变量，或者覆盖已存在的环境变量。</p>
<p>​       如：<strong>docker run –name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 -d mysql/mysql-server:latest</strong> </p>
<p>​      含义：容器的名字为mysql，将容器的3306端口映射到本机的3306端口，mysql数据库的密码为1234，运行的镜像为mysql/mysql-server:latest </p>
<p>​    4）<strong>docker ps：</strong> </p>
<p>​         <strong>-a</strong>  查看已经创建的容器</p>
<p>​         <strong>-s</strong>  查看已经启动的容器</p>
<p>​    5）<strong>docker start  containerName</strong>    启动容器名为containerName的容器。</p>
<p>​    6）<strong>docker stop  containerName</strong>     停止容器名为containerName的容器。</p>
<p>​    7）<strong>docker  rm    containerName</strong>     删除容器名为containerName的容器。</p>
<p>​    8）<strong>docker  rmi   img_name</strong>              删除镜像名为img_name的镜像。</p>
<p>​    9）<strong>docker rename  old_name  new_name</strong>    重命名一个容器。</p>
<p>​    10) *<em>docker exec *</em>  进入容器</p>
<p>​        如：docker exec  -it  container_Id/container_Name  bash  进入容器，并进入到bash中</p>
<p>​            docker exec  -it  container_name /bin/bash  进入容器并，进入到bash中</p>
<p>​             有三个参数：</p>
<p>​                -it：进入交互模式 </p>
<p>​                -d：在后台运行。</p>
<p>​    11）<strong>docker search xx</strong>：查找docker hub上的所有镜像。</p>
<p>​    12）<strong>docker inspect containerId(容器ID或容器名)</strong>  ： 查看对应容器的具体配置信息 </p>
<p>​    13）<strong>docker port containerId</strong> ： 查看对应容器端口映射 </p>
<p>​    14）<strong>docker cp  dir  newDir</strong>： 拷贝.既可以拷贝文件也可以拷贝整个目录.可以在本机和容器中相互拷贝!!</p>
<p>​        如：        </p>
<p>​                 <strong>docker cp myTomcat:/opt/apache-tomcat-7.0.62/webapps D:/docker_tomcat</strong> ：将myTomcat容器下的/opt/apache-tomcat-7.0.62/webapps目录拷贝到本机的D:/docker_tomcat中。</p>
<p>​         <strong>docker cp nginx:/usr/share/nginx/html/index.html D:/docker_nginx2</strong> ： 将nginx容器下的/usr/share/nginx/html/index.html文件拷贝到D:/docker_nginx2中。</p>
<pre><code>15）**docker top  containerName:**查看容器中运行的进程信息 </code></pre><p> <strong>docker run 和 docker start的区别：</strong>                </p>
<p>​        docker run 只在第一次运行时使用，将镜像放到容器中，以后再启动这个容器时，只需要使用命令docker start即可。</p>
<p>​        docker run相当于执行了两步操作：将镜像放入容器中（docker create），然后将容器启动，使之变成运行时容器（docker start）</p>
<p><img src="http://dockerone.com/uploads/article/20151103/ea18907dedcd8893b39ae1f9e3ad8a3e.png" alt="7.png">   </p>
<p>​    16）docker logs containerId 查看某一容器的日志</p>
<h4 id="docker安装mysql："><a href="#docker安装mysql：" class="headerlink" title="docker安装mysql："></a>docker安装mysql：</h4><p>​    1、拉取官方镜像：</p>
<p>​        docker pull mysql/mysql-server:latest</p>
<p>​    2、查看镜像：</p>
<p>​        docker images</p>
<p>​    3、创建并运行一个容器：</p>
<p>​        docker run –name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1234 -d mysql/mysql-server:latest</p>
<p>​    4、查看已经创建的容器：</p>
<p>​        docker ps -a</p>
<p>​    5、查看正在运行的容器：</p>
<p>​        docker ps -s</p>
<p>​    6、启动一个容器：</p>
<p>​        docker start container_name </p>
<p>​    7、进入容器内部连接mysql：</p>
<p>​        1) 首先进入容器内部,并进入bash： docker exec -it  containerId bash</p>
<p>​        2) mysql -u root -p </p>
<p>​    8、用本机连接mysql：</p>
<p>​        可以使用idea自带的mysql连接工具。</p>
<p>​          <strong>有个坑</strong>：</p>
<p>​            可能会有这种情况：进入容器内部是可以连接上MySQL的，但是本机连不上。</p>
<p>​            解决方法：</p>
<p>​                1）select host,user,plugin.authentication_string from mysql.user; 使用该命令查看root用户的访问权限，host为%代表不限制。否则是被限制的。</p>
<p>​                2）update mysql.user set host=’%’ where user = ‘root’; 修改root的host为%。</p>
<p>​                3） flush privileges; 命令本质上的作用是将当前user和privilige表中的用户信息/权限设置从mysql库(MySQL数据库的内置库)中提取到内存里。MySQL用户数据和权限有修改后，希望在”不重启MySQL服务”的情况下直接生效，那么就需要执行这个命令。通常是在修改ROOT帐号的设置后，怕重启后无法再登录进来，那么直接flush之后就可以看权限设置是否生效。而不必冒太大风险。</p>
<p>​                4) 再次用idea尝试连接mysql即可成功。</p>
<h4 id="docker安装tomcat："><a href="#docker安装tomcat：" class="headerlink" title="docker安装tomcat："></a>docker安装tomcat：</h4><p>​    1、<strong>docker search tomcat</strong> :  查询所有的tomcat</p>
<p>​    2、<strong>docker pull consol/tomcat-7.0</strong> ： 拉取一个镜像</p>
<p>​    3、<strong>docker run –name my-tomat -P -d consol/tomcat-7.0</strong> ： 随便创建一个容器</p>
<p>​        –name my-tomat ： 定义容器的名字为my-tomat </p>
<p>​        -P ：把容器的端口随机映射到本机的一个端口</p>
<p>​        -d： 后台运行容器</p>
<p>​        consol/tomcat-7.0：镜像的名字</p>
<p>​    4、查看docker中的tomcat是在哪个目录中：</p>
<p>​        1）首先需要启动容器。   docker run …</p>
<p>​        2）进入容器内部。    docker exec -it …</p>
<p>​        3）查看目录。      ls </p>
<p>​        4）进入opt目录。  cd /opt</p>
<p>​        5）cd tomcat   pwd  ，即可查看tomcat的目录。</p>
<p>​    5、将docker中的tomcat中的conf、logs、webapps三个文件夹拷贝到本地中：</p>
<p>​         <strong>docker cp myTomcat:/opt/apache-tomcat-7.0.62/webapps D:/docker_tomcat</strong></p>
<p>​        myTomcat是容器的名字；/opt/apache-tomcat-7.0.62是第四步得到的tomcat在docker中的目录；</p>
<p>​        将在docker中的tomcat中的webapps目录拷贝到本地D盘docker_tomcat目录中。</p>
<p>​    6、<strong>docker run -P –name tomcat7 -v D:/docker_tomcat/webapps:/opt/apache-tomcat-7.0.62/webapps -v D:/docker_tomcat/conf:/opt/apache-tomcat-7.0.62/conf -v D:/docker_tomcat/logs:/opt/apache-tomcat-7.0.62/logs -d consol/tomcat-7.0</strong></p>
<p>​    这一步是真正的创建一个容器，并且是通过映射目录的方式。</p>
<p>​    -P： 把容器的端口随机映射到本机的一个端口</p>
<p>​    –name： tomcat7</p>
<p>​    -v  ：把docker中的webapps logs conf 目录分别映射到本机的my-tomcat中对应的目录中 </p>
<p>​    -v D:/docker_tomcat/webapps:/opt/apache-tomcat-7.0.62/webapps：将docker中的tomcat中的webapps目录映射到本地的D:/docker_tomcat/webapps目录中。</p>
<p>​    这样映射有什么好处呢，就是把war包扔到本机的my-tomcat/webapps中就可以了啊 ，docker自动会部署到tomcat中的。修改了本机conf中的配置文件，docker中的配置文件也会立即生效的欧，因为已经映射了嘛，不相信的话你可以修改一下，然后进入docker中确认一下。</p>
<p> <strong>通过映射目录的方式，以后只要把war包放到映射目录里，Docker会自动拷贝一份到容器中，是不是很方便呢。</strong> </p>
<p>​    </p>
<h4 id="安装redis："><a href="#安装redis：" class="headerlink" title="安装redis："></a>安装redis：</h4><p>​    docker run -d -p 6379:6379 –name redis01 redis  运行容器</p>
<p>​    docker exec -it redis01 redis-cli  从容器进入redis客户端</p>
<h4 id="安装nginx："><a href="#安装nginx：" class="headerlink" title="安装nginx："></a>安装nginx：</h4><p>​    docker run -d -p 80:80 nginx   吧容器中的nginx的80端口映射到本机的80端口。（前面的是本机端口）</p>
<p>​    </p>
<p><strong>注意</strong>：当docker运行nginx时，外界访问还是docker所在的那个IP地址，就相当于nginx在那台机器上运行一样。但对于docker所在的那台机器来说，nginx就是附属于docker的一个镜像。若操作nginx还是由docker登录nginx容器，进行操作。登录的nginx容器就是一个linux系统，只不过只有nginx而已，nginx按照linux默认路径安装。  路径：/usr/share/nginx/html </p>
<p>通过映射目录的方式创建nginx容器：</p>
<p>​    <strong>docker run –name myNginx -p 23456:80 -d -v D:\\docker_nginx\\html:/usr/share/nginx/html nginx</strong></p>
<p>含义是吧docker中nginx中的html目录映射到 D:\\docker_nginx\\html 目录中。</p>
<h4 id="linux命令："><a href="#linux命令：" class="headerlink" title="linux命令："></a>linux命令：</h4><p>uname -a ：Linux查看版本当前操作系统内核信息 </p>
<p>cat /proc/version ：Linux查看当前操作系统版本信息 </p>
<p>cat /proc/cpuinfo：Linux查看cpu相关信息，包括型号、主频、内核信息等 </p>
<p>cat /etc/redhat-release：查看版本</p>
<p><strong>Dockerfile:</strong></p>
<p> 用来创建自定义的image，在包含Dockerfile文件的目录下可以使用build命令来创建新的image。</p>
<p>​    如： docker build -t wikift/wikift-server .</p>
<p>dockerfile文件 <strong>关键字</strong>：</p>
<p>1、 from     基于哪个镜像</p>
<p>2、run     安装软件用</p>
<p>3、MAINTAINER   镜像创建者</p>
<p>4、</p>
<h4 id="docker部署springboot项目："><a href="#docker部署springboot项目：" class="headerlink" title="docker部署springboot项目："></a>docker部署springboot项目：</h4><p> 1、springboot项目打包成jar包准备好。</p>
<p> 2、 编写Dockerfile文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line"></span><br><span class="line"># author infomation</span><br><span class="line">MAINTAINER lm</span><br><span class="line"></span><br><span class="line"># VOLUME 指定了临时文件目录为/tmp。其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp。改步骤是可选的，如果涉及到文件系统的应用就很有必要了。/tmp目录用来持久化到 Docker 数据文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用/tmp作为工作目录</span><br><span class="line">VOLUME /tmp</span><br><span class="line"></span><br><span class="line"># 项目的 jar 文件作为 “app.jar” 添加到容器</span><br><span class="line">ADD lmasm-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line"></span><br><span class="line">RUN sh -c &apos;touch /app.jar&apos;</span><br><span class="line"></span><br><span class="line">ENV JAVA_OPTS=&quot;&quot;</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar&quot; ]</span><br></pre></td></tr></table></figure>

<p> 3、 将两个文件放到同一文件夹下。</p>
<p> 4、使用命令： <strong>docker build -t spring-boot-docker .</strong>   构建镜像，运行完命令后可以看到生成了名为spring-boot-docker的镜像。</p>
<p>​    -t代表要构建的镜像的名字和标签，通常 name:tag 或者 name 格式，Tag默认是latest </p>
<p>​    .代表当前目录，也就是Dockerfile所在的目录。 </p>
<p> 5、使用命令：<strong>docker run -p 8080:8080 spring-boot-docker</strong>  运行容器。 </p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>js知识点整理</title>
    <url>/11/08/js-1/</url>
    <content><![CDATA[<h2 id="js知识点（一）"><a href="#js知识点（一）" class="headerlink" title="js知识点（一）"></a>js知识点（一）</h2><p>记录一些js的小而碎的知识点，没有什么顺序，想到什么了就记下来了，帮助以后复习总结。</p>
<a id="more"></a>

<h3 id="数组的一些常用方法？"><a href="#数组的一些常用方法？" class="headerlink" title="数组的一些常用方法？"></a>数组的一些常用方法？</h3><h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p> 1）find方法会返回数组中第一个为true的数组元素，否则返回undefined<br> 2）可以传一个箭头函数作为参数。<br> 例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> //查找id为3数组元素：</span><br><span class="line"></span><br><span class="line">messageDetail:[</span><br><span class="line">	&#123;id:1,title:&apos;message0001&apos;,content:&apos;content11&apos;&#125;,</span><br><span class="line">	&#123;id:2,title:&apos;message0002&apos;,content:&apos;content22&apos;&#125;,</span><br><span class="line">	&#123;id:3,title:&apos;message0003&apos;,content:&apos;content33&apos;&#125;</span><br><span class="line">]</span><br><span class="line">const md = messageDetail.find((md)=&gt; md.id ===3 )</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p> 1）map方法返回一个新数组，数组中的元素为原始元素调用函数处理后的值。<br> 2）map不会改变原始数组。</p>
<p> 例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) messages.map((message,index)=&gt;(</span><br><span class="line">	&lt;li key=&#123;index&#125;&gt;&#123;message&#125;&lt;/li&gt;</span><br><span class="line">   ))</span><br><span class="line"></span><br><span class="line">2) messages.map( (message,index)=&gt;&#123;</span><br><span class="line">	return (</span><br><span class="line">		&lt;li key=&#123;index&#125;&gt;&#123;message&#125;&lt;/li&gt;</span><br><span class="line">	   )</span><br><span class="line">	&#125;	            </span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<p>两种写法是一样的， 箭头后的函数体有两种写法：第一种： 大括号，需要加return() ；第二种：小括号，不需要加return语句。</p>
<h4 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h4><p>添加元素到末尾，可以添加任意多个。</p>
<p> arr.push(“Jack”,”Sean”)</p>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p>删除数组最后一项.</p>
<p> arr.pop()</p>
<h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><p>添加元素到开头，   </p>
<p>arr.unshift(“Jack”,”Sean”) </p>
<h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><p>删除数组的第一项，  </p>
<p>arr.shift()</p>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>排序数组，可以接收一个函数作为参数 ， 注意： 不能给数字数组排序，不过可以接收一个比较函数。  arr.sort(function(a,b){return a-b;})</p>
<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p>反转数组，原数组会被改变</p>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><p>截取数组， 一个参数的话是开头；两个参数的话不包括第二个参数的值。</p>
<p>splice() 可以实现对数组的删除、插入、和替换。</p>
<p><strong>删除</strong>： 可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。</p>
<p>例如， splice(0,2)会删除数组中的前两项。</p>
<p><strong>插入</strong>： 可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。</p>
<p>例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。</p>
<p> <strong>修改</strong>： 可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的</p>
<p>项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。</p>
<p>例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。</p>
<h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p>用于连接多个数组，返回一个新数组。</p>
<p>例如,  var arr = [1,2,3];   var arr2 = [4,5,6];   arr.concat(arr2)   // arr数组的值为：[1,2,3,4,5,6]</p>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>把数组中的所有元素放入一个字符串，元素是通过指定的分隔符进行分隔，默认为逗号。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，不会改变原数组。</p>
<p> 如： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr = [</span><br><span class="line">	&#123; id: 1, text: &apos;aa&apos;, done: true &#125;,</span><br><span class="line">	&#123; id: 2, text: &apos;bb&apos;, done: false &#125;</span><br><span class="line">]	</span><br><span class="line">console.log(arr.filter(item =&gt; item.done))    // [&#123;id: 1, text: &quot;aa&quot;, done: true&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="Object的一些方法？"><a href="#Object的一些方法？" class="headerlink" title="Object的一些方法？"></a>Object的一些方法？</h3><h4 id="Object-assign-target-source1-source2-…"><a href="#Object-assign-target-source1-source2-…" class="headerlink" title="Object.assign(target,source1,source2,…)"></a>Object.assign(target,source1,source2,…)</h4><p>该方法主要用于对象的合并，将源对象source的所有可枚举属性合并到目标对象target上,此方法只拷贝源对象的自身属性，不拷贝继承的属性。</p>
<p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>注意：<code>Object.assign</code> 方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。同名属性会替换。 </p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const target = &#123;</span><br><span class="line">    x : 0,</span><br><span class="line">    y : 1</span><br><span class="line">&#125;;</span><br><span class="line">const source = &#123;</span><br><span class="line">    x : 1,</span><br><span class="line">    z : 2 ,</span><br><span class="line">    fn : &#123;</span><br><span class="line">        number : 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Object.assign(target, source);  </span><br><span class="line">// target  &#123;x : 1, y : 1, z : 2, fn : &#123;number : 1&#125;&#125;    // 同名属性会被覆盖</span><br><span class="line">// source  &#123;x : 1, z : 2, fn : &#123;number : 1&#125;&#125;</span><br><span class="line">target.fn.number = 2;                                  // 拷贝为对象引用</span><br><span class="line">// source  &#123;x : 1, z : 2, fn : &#123;number : 2&#125;&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">function Person()&#123;</span><br><span class="line">    this.name = 1</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.country = &apos;china&apos;;</span><br><span class="line">let student = new Person();</span><br><span class="line">student.age = 29 ;</span><br><span class="line">const young = &#123;insterst : &apos;sport&apos;&#125;;</span><br><span class="line">Object.assign(young,student);</span><br><span class="line">// young &#123;instest : &apos;sport&apos; , age : 29, name: 1&#125;      // 只能拷贝自身的属性，不能拷贝prototype</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Object.assign([1, 2, 3], [4, 5])                      // 把数组当作对象来处理</span><br><span class="line">// [4, 5, 3]var target = &#123;&#125;;</span><br><span class="line">var source1 = &#123; b: 2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123; b:2, c:3&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p>返回由key组成的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var data=&#123;a:1,b:2,c:9,d:4,e:5&#125;;</span><br><span class="line">console.log(data);                          //&#123;a: 1, b: 2, c: 9, d: 4, e: 5&#125;</span><br><span class="line">console.log(Object.keys(data));             //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class="line">Object.keys(data).map((key,item)=&gt;&#123;</span><br><span class="line">	console.log(key,data[key]);//key=&gt;属性名    data[key]=&gt;属性值</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Object-create-prototype-propertiesObject"><a href="#Object-create-prototype-propertiesObject" class="headerlink" title="Object.create(prototype[,propertiesObject])"></a><strong>Object.create</strong>(prototype[,propertiesObject])</h4><p>使用指定的原型对象及其属性去创建一个新的对象 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var parent = &#123;</span><br><span class="line">    x : 1,</span><br><span class="line">    y : 1</span><br><span class="line">&#125;</span><br><span class="line">var child = Object.create(parent,&#123;</span><br><span class="line">    z : &#123;                           // z会成为创建对象的属性</span><br><span class="line">        writable:true,</span><br><span class="line">        configurable:true,</span><br><span class="line">        value: &quot;newAdd&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(child);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/11/08/js-1/12.png" alt></p>
<h4 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h4><p>方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="noopener"><code>for...in</code></a>循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。 </p>
<p><code>Object.values</code>会过滤属性名为 Symbol 值的属性。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var an_obj = &#123; 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; &#125;;</span><br><span class="line">console.log(Object.values(an_obj)); // [&apos;b&apos;, &apos;c&apos;, &apos;a&apos;]</span><br><span class="line"> </span><br><span class="line">var obj = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; &#125;;</span><br><span class="line">console.log(Object.values(obj)); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>

<h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h4><p>返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="noopener"><code>for...in</code></a> 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;</span><br><span class="line">console.log(Object.entries(obj)); // [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]</span><br><span class="line"> </span><br><span class="line">const simuArray = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; &#125;;</span><br><span class="line">console.log(Object.entries(simuArray)); // [ [&apos;0&apos;, &apos;a&apos;], [&apos;1&apos;, &apos;b&apos;], [&apos;2&apos;, &apos;c&apos;] ]</span><br></pre></td></tr></table></figure>

<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>判断两个值是否相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.is(0, -0);            // false</span><br><span class="line">Object.is(-0, -0);           // true</span><br><span class="line">Object.is(NaN, 0/0);         // true</span><br><span class="line">Object.is(null, null);       // true</span><br><span class="line">var test = &#123; a: 1 &#125;;</span><br><span class="line">Object.is(test, test);       // true</span><br></pre></td></tr></table></figure>

<h4 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h4><p>冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。 </p>
<h4 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen()"></a>Object.isFrozen()</h4><p>判断一个对象是否被<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener">冻结</a>.</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>js知识点整理</title>
    <url>/11/08/js-2/</url>
    <content><![CDATA[<h2 id="js知识点（二）"><a href="#js知识点（二）" class="headerlink" title="js知识点（二）"></a>js知识点（二）</h2><p>记录一些js的小而碎的知识点，没有什么顺序，想到什么了就记下来了，帮助以后复习总结。</p>
<a id="more"></a>

<h4 id="js、es、nodejs的区别："><a href="#js、es、nodejs的区别：" class="headerlink" title="js、es、nodejs的区别："></a>js、es、nodejs的区别：</h4><p>​    <strong>-es</strong>：定义了各种语法，是语法和语义上的标准。 主要包括：语法、类型、语句、关键字、保留字、操作符、对象。<br>    <strong>-js</strong>: 基于es标准实现的，但除了ECMAScript（语言基础，如：语法、数据类型结构以及一些内置对象）外，还包括web API。 如DOM、BOM等。<br>    <strong>-nodejs</strong>: 除了包括es外，还包括操作系统、文件系统、网络系统、数据库等。基于V8引擎，运行在服务端的js。</p>
<h4 id="js判断数组中是否有某个值？"><a href="#js判断数组中是否有某个值？" class="headerlink" title="js判断数组中是否有某个值？"></a>js判断数组中是否有某个值？</h4><p>​    1、 array.indexOf    存在的话返回下标，否则返回-1<br>        2、 array.includes   存在返回true，否则返回false<br>        3、 array.find       返回数组中满足条件的第一个元素的值，没有返回undefined<br>        4、 array.findIndex  返回数组中满足条件的第一个元素的下标，没有返回-1</p>
<h4 id="数组扁平化？"><a href="#数组扁平化？" class="headerlink" title="数组扁平化？"></a>数组扁平化？</h4><p> 将多级数组转化为一级数组。如： let ary = [1, [2, [3, [4, 5]]], 6];  // -&gt; [1, 2, 3, 4, 5, 6]</p>
<p>​    1、 调用es6中的flat方法： ary = arr.flat(Infinity);<br>    2、 replace + split:  ary = str.replace(/([|])/g, ‘’).split(‘,’)<br>    3、 replace + JSON.parse：</p>
<pre><code>str = str.replace(/(\[|\]))/g, &apos;&apos;);
str = &apos;[&apos; + str + &apos;]&apos;;
ary = JSON.parse(str);</code></pre><p>​    4、 扩展运算符：</p>
<pre><code>//只要有一个元素有数组，那么循环继续
while (ary.some(Array.isArray)) {
ary = [].concat(...ary);
}</code></pre><h4 id="高阶函数？"><a href="#高阶函数？" class="headerlink" title="高阶函数？"></a>高阶函数？</h4><p>一个函数接收另一个函数作为参数或者返回值为一个函数，这种函数就是高阶函数。</p>
<p><strong>1、map</strong></p>
<p>接收两个参数，一个是函数，另一个是函数的this值<br>创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果<br>对原来的数组没有影响</p>
<pre><code>let nums = [1, 2, 3];
let obj = {val: 5};
let newNums = nums.map(function(item,index,array) {
    return item + index + array[index] + this.val; 
    //对第一个元素，1 + 0 + 1 + 5 = 7
    //对第二个元素，2 + 1 + 2 + 5 = 10
    //对第三个元素，3 + 2 + 3 + 5 = 13
}, obj);
console.log(newNums);//[7, 10, 13]</code></pre><p><strong>2、reduce</strong></p>
<p>参数: 接收两个参数，一个为回调函数，另一个为初始值。回调函数中三个默认参数，依次为积累值、当前值、整个数组。</p>
<pre><code>let nums = [1, 2, 3];
// 多个数的加和
let newNums = nums.reduce(function(preSum,curVal,array) {
    return preSum + curVal; 
}, 0);
console.log(newNums);//6

不传默认值会自动以第一个元素为初始值，然后从第二个元素开始依次累计。</code></pre><p><strong>3、filter</strong></p>
<p>参数: 一个函数参数。这个函数接受一个默认参数，就是当前元素。这个作为参数的函数返回值为一个布尔类型，决定元素是否保留。<br>filter方法返回值为一个新的数组，这个数组里面包含参数里面所有被保留的项。</p>
<pre><code>let nums = [1, 2, 3];
// 保留奇数项
let oddNums = nums.filter(item =&gt; item % 2);
console.log(oddNums);</code></pre><p><strong>4、sort</strong></p>
<p>参数: 一个用于比较的函数，它有两个默认参数，分别是代表比较的两个元素。</p>
<p>注意：就是比较函数不传的时候，是将数字转换为字符串，然后根据字母unicode值进行升序排序，也就是根据字符串的比较规则进行升序排序。</p>
<h4 id="浅拷贝深拷贝？"><a href="#浅拷贝深拷贝？" class="headerlink" title="浅拷贝深拷贝？"></a>浅拷贝深拷贝？</h4><p>浅拷贝：</p>
<pre><code>let arr = [1, 2, 3];
let newArr = arr.slice();
newArr[0] = 100;
console.log(arr);//[1, 2, 3]</code></pre><p>当修改newArr的时候，arr的值并不改变。什么原因?因为这里newArr是arr浅拷贝后的结果，newArr和arr现在引用的已经不是同一块空间啦！这就是浅拷贝！<br>但是这又会带来一个潜在的问题:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 2, &#123;val: 4&#125;];</span><br><span class="line">let newArr = arr.slice();</span><br><span class="line">newArr[2].val = 1000;</span><br><span class="line">console.log(arr);//[ 1, 2, &#123; val: 1000 &#125; ]</span><br></pre></td></tr></table></figure>

<p>浅拷贝只能拷贝一层对象。如果有对象的嵌套，那么浅拷贝将无能为力。需要使用深拷贝。<br>实现浅拷贝的几种方式：</p>
<p>1、手动实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const shallowClone = (target) =&gt; &#123;</span><br><span class="line">    if (typeof target === &apos;object&apos; &amp;&amp; target !== null) &#123;</span><br><span class="line">        const cloneTarget = Array.isArray(target) ? []: &#123;&#125;;</span><br><span class="line">        for (let prop in target) &#123;</span><br><span class="line">           if (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">               cloneTarget[prop] = target[prop];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return cloneTarget;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       return target;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、Object.assign</p>
<pre><code>Object.assgin() 拷贝的是对象的属性的引用，而不是对象本身。

let obj = { name: &apos;sy&apos;, age: 18 };
const obj2 = Object.assign({}, obj, {name: &apos;sss&apos;});
console.log(obj2);//{ name: &apos;sss&apos;, age: 18 }</code></pre><p>3、concat浅拷贝数组</p>
<pre><code>let arr = [1, 2, 3];
let newArr = arr.concat();
newArr[1] = 100;
console.log(arr);//[ 1, 2, 3 ]</code></pre><p> 4、slice浅拷贝</p>
<p> 5、展开运算符</p>
<pre><code>let arr = [1, 2, 3];
let newArr = [...arr];//跟arr.slice()是一样的效果</code></pre><p><strong>深拷贝：</strong></p>
<p>1、JSON.parse(JSON.stringify());</p>
<pre><code>但是这种方法会有一些问题：
1） 无法解决循环引用的问题。
2） 无法拷贝函数。
3） 无法拷贝特殊的对象，如RegExp，Date，Set，Map等，</code></pre><h4 id="typeof和instanceof"><a href="#typeof和instanceof" class="headerlink" title="typeof和instanceof"></a>typeof和instanceof</h4><p>1、对于原始类型来说，除了null，typeof都能显示正确的类型。注意，null不是对象。虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。</p>
<p>2、对于引用类型(数组，对象)来说，除了函数显示function，其他都显示object。</p>
<p>3、typeof 一般只能返回如下几个结果：”number”、”string”、”boolean”、”object”、”function” 和 “undefined”</p>
<p>4、采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true</p>
<p>5、手动实现instanceof？ 核心： 原型链的向上查找</p>
<pre><code>function myInstanceof(left, right) {
    //基本数据类型直接返回false
    if(typeof left !== &apos;object&apos; || left === null) return false;
    //getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left);
    while(true) {
        //查找到尽头，还没找到
        if(proto == null) return false;
        //找到相同的原型对象
        if(proto == right.prototype) return true;
        proto = Object.getPrototypeof(proto);
    }
}</code></pre><h4 id="Object-is-和"><a href="#Object-is-和" class="headerlink" title="Object.is 和 ==="></a>Object.is 和 ===</h4><p>Object在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。 源码如下：</p>
<pre><code>function is(x, y) {
    if (x === y) {
        //运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的
        return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
        //NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理
        //两个都是NaN的时候返回true
        return x !== x &amp;&amp; y !== y;
     }
}</code></pre><h4 id="和"><a href="#和" class="headerlink" title="== 和 ==="></a>== 和 ===</h4><p>===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如’1’===1的结果是false，因为一边是string，另一边是number。<br>==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下：</p>
<p>​    两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false<br>    判断的是否是null和undefined，是的话就返回true<br>    判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较<br>    判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较<br>    如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较</p>
<pre><code>console.log({a: 1} == true);//false
console.log({a: 1} == &quot;[object Object]&quot;);//true</code></pre><h4 id="对象转为原始类型是根据什么流程运行的"><a href="#对象转为原始类型是根据什么流程运行的" class="headerlink" title="对象转为原始类型是根据什么流程运行的?"></a>对象转为原始类型是根据什么流程运行的?</h4><p>对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</p>
<p>1、如果Symbol.toPrimitive()方法，优先调用再返回<br>2、调用valueOf()，如果转换为原始类型，则返回<br>3、调用toString()，如果转换为原始类型，则返回<br>4、如果都没有返回原始类型，会报错</p>
<p>例子：</p>
<pre><code>var obj = {
    value: 3,
    valueOf() {
        return 4;
    },
    toString() {
        return &apos;5&apos;
    },
    [Symbol.toPrimitive]() {
        return 6
    }
}
console.log(obj + 1); // 输出7</code></pre><p>应用：如何让if(a == 1 &amp;&amp; a == 2)条件成立？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    value: 0,</span><br><span class="line">    valueOf: function() &#123;</span><br><span class="line">        this.value++;</span><br><span class="line">        return this.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(a == 1 &amp;&amp; a == 2); //true</span><br></pre></td></tr></table></figure>

<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>什么是闭包：</p>
<pre><code>闭包是指有权访问另外一个函数作用域中的变量的函数。
   闭包产生的本质就是，当前环境中存在指向父级作用域的引用。</code></pre><p>闭包产生的原因：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">       var a = 2</span><br><span class="line">       function f2() &#123;</span><br><span class="line">           console.log(a);//2</span><br><span class="line">       &#125;</span><br><span class="line">       return f2;</span><br><span class="line">   &#125;</span><br><span class="line">   var x = f1();</span><br><span class="line">   x();</span><br></pre></td></tr></table></figure>

<p> 这里x会拿到父级作用域中的变量，输出2。因为在当前环境中，含有对f2的引用，f2恰恰引用了window、f1和f2的作用域。因此f2可以访问到f1的作用域的变量。</p>
<p>并不是只有返回函数才算是产生了闭包，我们只需要让父级作用域的引用存在即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f3;</span><br><span class="line">   function f1() &#123;</span><br><span class="line">       var a = 2</span><br><span class="line">       f3 = function() &#123;</span><br><span class="line">           console.log(a);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">f1();</span><br><span class="line">f3();</span><br></pre></td></tr></table></figure>

<p>让f1执行，给f3赋值后，等于说现在f3拥有了window、f1和f3本身这几个作用域的访问权限，还是自底向上查找，最近是在f1中找到了a,因此输出2。</p>
<p>在这里是外面的变量f3存在着父级作用域的引用，因此产生了闭包，形式变了，本质没有改变。</p>
<p><strong>闭包的表现形式：</strong></p>
<p>  1、 返回一个函数。刚刚已经举例。<br>  2、 作为函数参数传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">   function foo()&#123;</span><br><span class="line">       var a = 2;</span><br><span class="line">       function baz()&#123;</span><br><span class="line">           console.log(a);</span><br><span class="line">       &#125;</span><br><span class="line">       bar(baz);</span><br><span class="line">   &#125;</span><br><span class="line">   function bar(fn)&#123;</span><br><span class="line">       // 这就是闭包</span><br><span class="line">       fn();</span><br><span class="line">   &#125;</span><br><span class="line">   // 输出2，而不是1</span><br><span class="line">   foo();</span><br></pre></td></tr></table></figure>

<p> 3、在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。</p>
<p>  以下的闭包保存的仅仅是window和当前作用域：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定时器</span><br><span class="line">setTimeout(function timeHandler()&#123;</span><br><span class="line">	console.log(&apos;111&apos;);</span><br><span class="line">&#125;，100)</span><br><span class="line"></span><br><span class="line">// 事件监听</span><br><span class="line">$(&apos;#app&apos;).click(function()&#123;</span><br><span class="line">	console.log(&apos;DOM Listener&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> 4、IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以使用全局的变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line">(function IIFE()&#123;</span><br><span class="line">	// 输出2</span><br><span class="line">	console.log(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h4><pre><code>function Person() {}
Person.prototype.name = &apos;Zaxlct&apos;;
Person.prototype.age  = 28;
Person.prototype.job  = &apos;Software Engineer&apos;;
Person.prototype.sayName = function() {
    alert(this.name);
}

var person1 = new Person();
person1.sayName(); // &apos;Zaxlct&apos;

var person2 = new Person();
person2.sayName(); // &apos;Zaxlct&apos;

console.log(person1.sayName == person2.sayName); //true</code></pre><p><img src="/11/08/js-2/123.png" alt></p>
<p>1、每个对象都有 <strong>proto</strong> 属性，但只有函数对象才有 prototype 属性<br>2、原型对象：就是proptype,即Person.proptype。<br>3、在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person）<br>    即 Person.prototype.constructor == Person<br>4、实例的构造函数属性指向构造函数，即 person1.constructor == Person<br>5、person1 为什么有 constructor 属性？那是因为 person1 是 Person 的实例。<br>    那 Person.prototype 为什么有 constructor 属性？？同理， Person.prototype （你把它想象成 A） 也是Person 的实例。<br>    也就是在 Person 创建的时候，创建了一个它的实例对象并赋值给它的 prototype<br>6、结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。<br>7、JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<strong>proto</strong> 的内置属性，用于指向创建它的构造函数的原型对象。<br>    即 person1.<strong>proto</strong> == Person.prototype</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack和babel知识整理</title>
    <url>/10/31/webpack_babel/</url>
    <content><![CDATA[<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>Babel是一个js的转码器，主要用于将es2015+ 的代码转换为向后兼容版本的js代码，从而可以在现有的环境中运行。</p>
<a id="more"></a>

<h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h4><p>babel是一个转译器，转译过程分为三个阶段：parsing、transforming、generating。具体转译过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ES6代码输入 ==》 babylon进行解析 ==》 得到AST</span><br><span class="line">==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树</span><br><span class="line">==》 用babel-generator通过AST树生成ES5代码</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>babel只会转译新标准引入的语法，比如ES6的箭头函数转译成ES5的函数 ；但是新标准中引入的新的原生对象，部分原生对象新增的原型方法，新增的API等（如Proxy、Set等）,这些babel是不会转译的 ，我们需要引入polyfill来解决。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">babylon：js的词法解析器</span><br><span class="line">babel-traverse：用于对AST（抽象语法树，想了解的请自行查询编译原理）的遍历，主要给plugin用</span><br><span class="line">babel-generator：根据AST生成代码</span><br></pre></td></tr></table></figure>

<p>下面是转译的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 转译前</span><br><span class="line">input.map(item =&gt; item + 1);</span><br><span class="line"></span><br><span class="line">// 转译后</span><br><span class="line">input.map(function (item) &#123;</span><br><span class="line">  return item + 1;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>箭头函数是es6的新特性，不能在浏览器中直接运行，babel可以将它转为普通的函数，这样就可以运行了。</p>
<h4 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h4><p>Babel的配置文件是<code>.babelrc</code>，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。 </p>
<p>该文件用来设置转码规则和插件 ，基本格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [],     // 设定转码规则，</span><br><span class="line">  &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便，Babel团队将一些<code>Plugins</code>集合在一起，并称之为<code>preset</code>。所以一个<code>preset</code>是一系列<code>plugin</code>的总和。</p>
<p>经常使用的规则集如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># js转码规则</span><br><span class="line">	npm install --save-dev babel-preset-env</span><br><span class="line"></span><br><span class="line"># react转码规则</span><br><span class="line">	npm install --save-dev babel-preset-react</span><br></pre></td></tr></table></figure>

<p>es20xx的preset只转译该年份批准的标准，而env则代指最新的标准，包括了latest和es20xx各年份. </p>
<p>之后在presets中加上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      &quot;env&quot;,</span><br><span class="line">      &quot;react&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: []</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="babel-cli"><a href="#babel-cli" class="headerlink" title="babel-cli"></a>babel-cli</h4><p>Babel提供<code>babel-cli</code>工具，用于命令行转码 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-cli</span><br></pre></td></tr></table></figure>

<p>基本用法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 转码结果输出到标准输出</span><br><span class="line"> babel example.js</span><br><span class="line"></span><br><span class="line"># 转码结果写入一个文件</span><br><span class="line"># --out-file 或 -o 参数指定输出文件</span><br><span class="line"> babel example.js --out-file compiled.js</span><br><span class="line"># 或者</span><br><span class="line"> babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"># 整个目录转码</span><br><span class="line"># --out-dir 或 -d 参数指定输出目录</span><br><span class="line"> babel src --out-dir lib</span><br><span class="line"># 或者</span><br><span class="line"> babel src -d lib</span><br><span class="line"></span><br><span class="line"># -s 参数生成source map文件</span><br><span class="line"> babel src -d lib -s</span><br></pre></td></tr></table></figure>

<p>本地安装babel-cli后可以将命令配置到package.json文件中的script脚本中来执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;:&#123;</span><br><span class="line">    &quot;build&quot;:&quot;babel demo.js --out-file bundle.js&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="babel-core"><a href="#babel-core" class="headerlink" title="babel-core"></a>babel-core</h4><p>babel转译器本身，提供了babel的转译API，如babel.transform等 ，用于对代码进行转译。像webpack的babel-loader就是调用这些API来完成转译过程的。 下面是babel-core中的几个api</p>
<ul>
<li><p>babel.transform：用于字符串转码得到AST</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* @param &#123;string&#125; code 要转译的代码字符串</span><br><span class="line">* @param &#123;object&#125; options 可选，配置项</span><br><span class="line">* @return &#123;object&#125;</span><br><span class="line">*/</span><br><span class="line">babel.transform(code: string, options?: Object)</span><br><span class="line"></span><br><span class="line">//返回一个对象(主要包括三个部分)： </span><br><span class="line">&#123;</span><br><span class="line">    generated code, //生成码</span><br><span class="line">    sources map, //源映射</span><br><span class="line">    AST //即abstract syntax tree，抽象语法树</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>babel.transformFile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//异步的文件转码方式，回调函数中的result与transform返回的对象一至。</span><br><span class="line"> </span><br><span class="line">babel.transformFile(&quot;filename.js&quot;, options, function(err, result)&#123;</span><br><span class="line"> </span><br><span class="line">result; // =&gt; &#123; code, map, ast &#125;</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>babel.transformFileSync</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//同步的文件转码方式，返回结果与transform返回的对象一至。</span><br><span class="line"> </span><br><span class="line">babel.transformFileSync(filename, options) // =&gt; &#123; code, map, ast &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>babel.transformFromAst</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将ast进行转译</span><br><span class="line"> </span><br><span class="line">const &#123; code, map, ast &#125; = babel.transformFromAst(ast, code, options);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h4><p>abel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如<code>Object.assign</code>）都不会转码。</p>
<p>举例来说，ES6在<code>Array</code>对象上新增了<code>Array.from</code>方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用<code>babel-polyfill</code>，为当前环境提供一个垫片。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-polyfill</span><br></pre></td></tr></table></figure>

<p>然后，在脚本头部，加入如下一行代码。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;babel-polyfill&apos;;</span><br><span class="line">// 或者</span><br><span class="line">require(&apos;babel-polyfill&apos;);</span><br></pre></td></tr></table></figure>

<h4 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h4><p>babel编译时会在每个文件生成一些需要帮助函数，如果文件比较多，那么这些重复的代码会增加编译后的代码体积 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;</span><br><span class="line"></span><br><span class="line">var G = function G() &#123;</span><br><span class="line">  _classCallCheck(this, G);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// _classCallCheck就是一个内部生成的帮助函数</span><br></pre></td></tr></table></figure>

<p>使用runtime后会直接从babel-runtime中引入帮助函数，就减少了文件体积。使用方法如下：</p>
<p>1、首先需要安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-plugin-transform-runtime</span><br><span class="line"> </span><br><span class="line">npm install --save babel-runtime</span><br></pre></td></tr></table></figure>

<p>2、在babelrc文件中配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;],</span><br><span class="line">  &quot;plugins&quot;: [&quot;transform-runtime&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="babel-register"><a href="#babel-register" class="headerlink" title="babel-register"></a>babel-register</h4><p>这是babel的一个注册器，它在底层改写了node的require方法，引入babel-register之后所有require并以.es6, .es, .jsx 和 .js为后缀的模块都会经过babel的转译。 </p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>模块打包工具</p>
<h4 id="安装执行命令："><a href="#安装执行命令：" class="headerlink" title="安装执行命令："></a>安装执行命令：</h4><p>npm init  初始化</p>
<p>npm install webpack webpack-cli -g  全局安装webpack</p>
<p>npm install webpack webpack-cli -D == npm install webpack webpack-cli –save -dev 将webpack安装在项目内</p>
<p>npx webpack -v  查看webpack安装的版本</p>
<p>npm info webpack  查看webpack的所有版本</p>
<p>npm install <a href="mailto:webpack@4.16.5" target="_blank" rel="noopener">webpack@4.16.5</a> webpack-cli -D  安装指定版本的webpack</p>
<p>npx webpack  打包命令</p>
<p>npx webpack –config webpackXXX.js  使用webpackXXX作为配置文件来打包， webpack.config.js文件是默认配置文件</p>
<h4 id="entry和output："><a href="#entry和output：" class="headerlink" title="entry和output："></a>entry和output：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'production'</span>,  <span class="comment">// mode 打包模式 production为默认模式，当值为develpoment时代码不会被压缩</span></span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当有多个入口、出口文件时，且页面引用的js文件需要加一个前缀：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> entry: &#123;</span><br><span class="line">     main: &apos;./src/index.js&apos;,</span><br><span class="line">     sub: &apos;./src/index.js&apos;</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    publicPath: &apos;www.cdn.com&apos;,</span><br><span class="line">    filename: &apos;[name].js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;build&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scripts脚本：package.json文件中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>那么，打包时就可以使用命令 npm run build, 不再需要npx webpack了。</p>
<h4 id="loader"><a href="#loader" class="headerlink" title="loader:"></a>loader:</h4><p>​    webpack不能识别非js的文件，所以需要用laoder来告诉webpack如何去识别其他的文件。</p>
<p>​    loader加载顺序：从下到上，从右到左。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">     rules: [</span><br><span class="line">         &#123;</span><br><span class="line">             test: /\.(jpg|png|gif)$/,</span><br><span class="line">             use: &#123;</span><br><span class="line">                 loader: &apos;file-loader&apos;,</span><br><span class="line">                 options: &#123;</span><br><span class="line">                     // placeholder 占位符 </span><br><span class="line">                     name: &apos;[name]_[hash].[ext]&apos;,    //打包后的图片名</span><br><span class="line">                     outputPath: &apos;images/&apos;           //打包后的路径</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(jpg|png|gif)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &apos;url-loader&apos;,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        // placeholder 占位符 </span><br><span class="line">                        name: &apos;[name]_[hash].[ext]&apos;,</span><br><span class="line">                        outputPath: &apos;images/&apos;,</span><br><span class="line">                        limit: 10240</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>file-loader与url-loader是很相似的，但使用file-loader时，是将图片变为base64形式的加载，可以减少文件的加载数，通过limit可以限制，当超过10240也就是10k时使用base64形式，否则还是打包成一个图片。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.scss$/,</span><br><span class="line">    use: [</span><br><span class="line">    &apos;style-loader&apos;,</span><br><span class="line">    &apos;css-loader&apos;,</span><br><span class="line">    &apos;sass-loader&apos;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用scss的话需要安装 sass-loader 和node-sass两个包。</p>
<h4 id="plguins："><a href="#plguins：" class="headerlink" title="plguins："></a>plguins：</h4><p>​    plugin可以在webpack运行到某一时刻时，自动帮我们做一些事情，像是react中的生命周期函数一样。</p>
<p>​    <strong>htmlWebpackPlugin 插件：</strong></p>
<p>​    会在打包结束后，自动生成一个html文件，并吧打包生成的js自动引入到这个 html文件中。可以在temlplate中配置模板。</p>
<p>​    <strong>cleanWebpackPlugin插件：</strong></p>
<p>​    会首先执行，删除打包的目录。之后会继续生成新的打包目录。</p>
<p>​    webpack4版本写法：</p>
<p>​    <strong>const { CleanWebpackPlugin } = require(‘clean-webpack-plugin’);</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">        new HtmlwebpackPlugin(&#123;</span><br><span class="line">            template: &apos;./src/index.html&apos;</span><br><span class="line">        &#125;),</span><br><span class="line">        new CleanWebpackPlugin()</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>

<h4 id="source-map"><a href="#source-map" class="headerlink" title="source-map:"></a>source-map:</h4><p>当打包生成的文件出错的时候，如果不用sourcemap，我们只能知道打包后的文件出错的地方在哪里，并不能知道源代码出错的地方在哪里，sourcemap可以帮助我们做这两个的文件映射。</p>
<p>cheap: 只提示哪一行出错，不会提示哪一列出错。只负责业务代码中的错误。</p>
<p>module: 不仅负责提示业务代码出现的错误，还会提示loader中出现的错误。</p>
<p>eval：被压缩文件有做module 编译速度最快。</p>
<p>常用配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devtool:  cheap-module-eval-source-map</span><br><span class="line"></span><br><span class="line">devtool: cheap-module-source-map</span><br></pre></td></tr></table></figure>

<h4 id="devServer"><a href="#devServer" class="headerlink" title="devServer:"></a>devServer:</h4><p>webpack-dev-server可以帮助我们快速开发应用程序</p>
<p>三种方式配置。</p>
<p>1、watch方式： 可以幫助我們自動打包，但是我們需要自己打开浏览器去运行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、webpack-dev-server 方式：可以帮助我们自动打包，同时会自动打开浏览器运行。默认8080端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">      contentBase: &apos;./build&apos;,</span><br><span class="line">      open: true,</span><br><span class="line">      proxy: &#123;</span><br><span class="line">          &apos;/api&apos;: &apos;http://localhost:3000&apos;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="HMR："><a href="#HMR：" class="headerlink" title="HMR："></a>HMR：</h4><p> hot module replacement, 热更新, 在程序运行过程中，修改时不需要重新加载整个页面。会只更新变更的内容，当我们修改源代码中的js/css文件时，会立刻在浏览器中进行更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line"> plugins:[</span><br><span class="line">	new webpack.HotModuleReplacementPlugin()</span><br><span class="line"> ]</span><br><span class="line"> </span><br><span class="line"> devServer: &#123;</span><br><span class="line">     contentBase: &apos;./build&apos;,</span><br><span class="line">     open: true,</span><br><span class="line">     proxy: &#123;</span><br><span class="line">         &apos;/api&apos;: &apos;http://localhost:3000&apos;</span><br><span class="line">     &#125;,</span><br><span class="line">     hot: true,</span><br><span class="line">     hotOnly: true</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Babel配置"><a href="#Babel配置" class="headerlink" title="Babel配置"></a>Babel配置</h4><p>首先安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-loader @babel/core</span><br><span class="line">npm install --save-dev @babel/preset-env</span><br></pre></td></tr></table></figure>

<p>然后配置规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">    	  test: /\.js$/, </span><br><span class="line">          exclude: /node_modules/, </span><br><span class="line">          loader: &quot;babel-loader&quot;,</span><br><span class="line">          options: &#123;</span><br><span class="line">              presets: [[&apos;@babel/preset-env&apos;,&#123;</span><br><span class="line">              useBuiltIns: &apos;usage&apos;</span><br><span class="line">          	&#125;]]</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title>React知识整理</title>
    <url>/10/30/react/</url>
    <content><![CDATA[<h4 id="1、性能高"><a href="#1、性能高" class="headerlink" title="1、性能高"></a>1、性能高</h4><p><strong>1) 虚拟DOM，不总是直接操作DOM</strong>     </p>
<pre><code>React将DOM抽象为虚拟DOM，虚拟DOM其实就是用一个对象来描述DOM，通过对比前后两个对象的    差异，最终只把变化的部分重新渲染，提高渲染的效率
  虚拟DOM比较轻，原生dom有200多个属性，比较重。</code></pre><a id="more"></a>

<p>创建虚拟DOM方式：<br>      1）createElement()方式：不友好，太复杂<br>             创建虚拟DOM：<br>             //参数1：元素名称  参数2：元素属性对象(null表示无)  参数3：当前元素的子元素string||createElement() 的返回值<br>              React.createElement(‘div’,{title:’hello’},’hello React’)<br>         渲染虚拟DOM：<br>             // 参数1：虚拟dom对象  参数2：dom对象表示渲染到哪个元素内 参数3：回调函数<br>             ReactDOM.render(div,document.getElementById(‘app’))                  </p>
<p>​    2）JSX方式</p>
<p>​           jsx方最终扔被编译为createElement()方法<br>               推荐：使用 JSX 的方式创建组件<br>               JSX - JavaScript XML<br>               注意：JSX的语法需要通过 babel-preset-react 编译后，才能被解析执行</p>
<p>​          注意点：<br>                    注意 1: 如果在 JSX 中给元素添加类, 需要使用 className 代替 class  , 类似：label 的 for属性，使用htmlFor代替<br>                    注意 2：在 JSX 中可以直接使用 JS代码，直接在 JSX 中通过 {} 中间写 JS代码即可<br>                    注意 3：在 JSX 中只能使用表达式，但是不能出现 语句！！！<br>                    注意 4：在 JSX 中注释语法：{/* 中间是注释的内容 */} </p>
<p><strong>2) DOM diff算法</strong></p>
<p><img src="/10/30/react/12.png" alt></p>
<p>​    实际上react的diff算法大大的提升了两个虚拟dom的比对性能，如图，虚拟dom什么时候会被比对，当数据发生改变的时候，虚拟dom才会去做新的比对，那么什么时候数据发生了改变了呢，要么改变了props，要么改变了state。其实props的改变是因为父组件的state发生了改变，所以其实都是setState数据才发生变化。之前说过setState是异步的，那么为什么是异步呢，实际上是为了提升react底层的性能，假设连续调用三次setState，变更三组数据，那么就会进行三次虚拟dom的比对，然后更新三次页面，假设三次改变，时间间隔非常的小，这样会比较浪费性能，所以react，把三次比对变成一次比对，这样就会优化比对带来的性能问题，所以设置react为异步函数。接下来看具体的diff算法 。</p>
<p><img src="/10/30/react/13.png" alt></p>
<p>​    如图，diff算法有个很重要的概念，叫做同级比较，首先会比较最顶层的虚拟dom节点是否一致，假设一致，再去比较下一个节点。假设第一层虚拟dom不一致，这个时候怎么办呢？这个时候react就不会往下比了，他会原始的虚拟dom下面的节点全部删除掉，重新生成一遍节点下面的所有dom，然后用重新生成的dom，替换原始页面的dom，也就是只比对一层dom，大家可能会想，这不是性能很低吗？假设第一层节点不同，下面的节点都相同，岂不是下面的节点都没法复用了，确实是这样的，虽然会造成一些dom节点的渲染浪费，但是这种比对有什么好处呢？我们说同层比对，带来的算法非常的简单，只要一层一层的做对比就行了，算法简单，带来的好处就是比对的速度会非常的快，所以可能会造成重新渲染的一些浪费，但大大减少了去比对的算法上的性能消耗。所以采用了同层比对的算法。 </p>
<h4 id="2、state-和props"><a href="#2、state-和props" class="headerlink" title="2、state 和props"></a>2、state 和props</h4><p><strong>1) state</strong></p>
<p>  1、state是组件对象最为重要的属性，值是对象（可以包含多个数据）        </p>
<p>  2、组件被称为状态机，通过更新组件的state重新渲染页面。        </p>
<p>  3、初始化state： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      stateProp1 : value1,</span><br><span class="line">      stateProp2 : value2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>   4、读取某个state： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.state.statePropertyName</span><br></pre></td></tr></table></figure>

<p>   5、更新state –&gt; 组件界面更新 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">    stateProp1 : value1,</span><br><span class="line">    stateProp2 : value2</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>2) props</strong></p>
<p>   1、每个组件对象都会有props属性；组件标签的所有属性都保存在props中。               </p>
<p>   2、通过标签属性从组件外向组件内传递数据； 注意： 组件内部不要修改props数据。         </p>
<p>   3、内部读取某个属性值： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.props.propertyName</span><br></pre></td></tr></table></figure>

<p>   4、对props中的属性值进行类型限制和非必要限制： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Person.propTypes = &#123;</span><br><span class="line">	name: PropTypes.string.isRequired,</span><br><span class="line">	age: PropTypes.number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   5、默认属性值： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person.defaultProps = &#123;</span><br><span class="line">	name: &apos;Mary&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3) refs</strong></p>
<p>   1、组件内的标签都可以定义ref属性来标识自己           </p>
<p>​        a. &lt;input type=”text” ref={input =&gt; this.msgInput = input}/&gt;                 </p>
<p>​        b. 回调函数在组件初始化渲染完或卸载时自动调用           </p>
<p>​    2、在组件中可以通过this.msgInput来得到对应的真实DOM元素 </p>
<p><strong>注意点：</strong></p>
<p>​    1、不要直接修改state属性的值，这样不会重新渲染组件。</p>
<p>​    2、 state和props的主要区别是 props是不可变的，而state可以根据与用户交互来改变。</p>
<p>​    3、React只需要更新组件的state，然后根据新的state重新渲染用户界面（不要操作DOM）。<br>        修改完state状态后，会自动调用render渲染界面。</p>
<h4 id="3、生命周期"><a href="#3、生命周期" class="headerlink" title="3、生命周期"></a>3、生命周期</h4><p>​                                             </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounting                     updating                    unmounting</span><br><span class="line">  getDefaultProps()         componentWillReceiveProps        componentWillUnmount</span><br><span class="line">          |                               |</span><br><span class="line">          |                               |</span><br><span class="line">    getInitialState()         shouldComponentUpdate    </span><br><span class="line">          |                               |</span><br><span class="line">          |                         true  |</span><br><span class="line">    componentWillMount           componentWillUpdate</span><br><span class="line">          |                               |</span><br><span class="line">          |                               |</span><br><span class="line">        render                          render</span><br><span class="line">          |                               |</span><br><span class="line">          |                               |</span><br><span class="line">    componentDidMount            componentDidUpdate</span><br></pre></td></tr></table></figure>

<p><strong>1) mounting时期：</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentWillMount  //组件被挂载到页面之前执行（只会执行一次）</span><br><span class="line">componentDidMount   //组件被挂载到页面之后执行（只会执行一次）</span><br></pre></td></tr></table></figure>

<p><strong>2) Updating时期：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//当子组件将要从父组件接收参数时执行</span><br><span class="line">//如果这个子组件第一次存在于父组件中，不会执行</span><br><span class="line">//当这个子组件仍存在于父组件中，才会被执行</span><br><span class="line">componentWillReceiveProps</span><br><span class="line"></span><br><span class="line">//componentWillReceiveProps之后，componentWillUpdate之前执行</span><br><span class="line">//用于判断页面是否需要被更新</span><br><span class="line">//需要有返回值（Boolean类型）: true 页面需要更新，false 页面不需要更新</span><br><span class="line">shouldComponentUpdate</span><br></pre></td></tr></table></figure>

<p><strong>3) unmounting时期：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentWillUnmount</span><br></pre></td></tr></table></figure>

<p><strong>4) 哪些生命周期函数不能调用setState方法，调了之后会怎么样？</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、constructor()函数中不要调用setState方法，控制台会产生警告。为state赋值的话使用this.state 就行。</span><br><span class="line">2、componentWillMount 可以调用setState方法，但是组件不会重新渲染，因为它在render之前执行。</span><br><span class="line">3、render函数中不能调用setState方法，会导致循环调用。</span><br><span class="line">4、componentDidMount 可以调用setState方法。                                                       5、componentWillReceiveProps 可以调用setState方法，该方法仅在父组件重新渲染时触发。                </span><br><span class="line">6、shouldComponentUpdate 不能调用setState方法，会导致循坏调用。</span><br><span class="line">7、componentWillUpdate 不能调用setState方法，会导致循坏调用。</span><br><span class="line">8、componentDidUpdate 不能调用setState方法，会导致循坏调用。</span><br><span class="line">9、componentWillUnmount 调用setState无意义。</span><br></pre></td></tr></table></figure>

<p> <strong>5) 父子组件执行顺序</strong></p>
<p>第一次渲染时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父组件constructor执行 -&gt; 父组件componentWillMount执行 -&gt; </span><br><span class="line">子组件constructor执行 -&gt; 子组件componentWillMount执行 -&gt;</span><br><span class="line">子组件componentDidMount执行 -&gt; 父组件componentDidMount执行</span><br></pre></td></tr></table></figure>

<p>当父组件更新时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父组件shouldComponentUpdate执行 -&gt; 父组件componentWillUpdate执行 -&gt; 父组件render -&gt;</span><br><span class="line">子组件componentWillReceiveProps执行 -&gt; 子组件shouldComponentUpdate执行 -&gt; 子组件componentWillUpdate执行 -&gt; 子组件 render -&gt; 子组件componentDidUpdate执行 -&gt;</span><br><span class="line">父组件componentDidUpdate执行</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>前端单元测试库jest和enzyme介绍</title>
    <url>/10/30/jest_enzyme/</url>
    <content><![CDATA[<p>我们可以通过完善单元测试来提高代码质量，并在一定程度上提高开发效率。  </p>
<p>常见的 JS 单元测试框架有 mocha，jesmine，chai，Jest 等。</p>
<a id="more"></a>

<h2 id="jest"><a href="#jest" class="headerlink" title="jest"></a>jest</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Jest 是 Facebook 开源的一款 JS 单元测试框架，它也是 React 目前使用的单元测试框架。 目前除了 Facebook 外，Twitter、Nytimes、Airbnb 也在使用 Jest。Jest 除了基本的断言和 Mock 功能外，还有快照测试、实时监控模式、覆盖度报告等实用功能。 同时 Jest 几乎不需要做任何配置便可使用。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -D jest</span><br></pre></td></tr></table></figure>

<p>测试文件名字格式为 **.test.js，我们可以建一个<strong>_test</strong> _文件夹来存放测试文件。同时，快照也会生成到该文件夹下。</p>
<p>package.json文件中增加脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;test&quot;: &quot;jest --coverage --colors&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>下次启动直接 npm test 就可以啦。 </p>
<p>测试某个单独页面：npm test – src/js/dir1/xxx.test.js</p>
<p>测试某个单独页面并更新快照：npm test – src/js/dir1/xxx.test.js -u</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p> jest的配置文件名为 jest.config.js 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// jest.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    verbose: true,</span><br><span class="line">    moduleFileExtensions: [&apos;js&apos;, &apos;jsx&apos;],   // </span><br><span class="line">    testRegex: &apos;sum.test.js&apos;,    // 只测试某些文件</span><br><span class="line">    // snapshotSerializers: [&apos;enzyme-to-json/serializer&apos;],</span><br><span class="line">    coveragePathIgnorePatterns: [],</span><br><span class="line">    testPathIgnorePatterns: [&apos;/node_modules/&apos;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// jest.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    verbose: true,</span><br><span class="line">    moduleFileExtensions: [&apos;js&apos;, &apos;jsx&apos;],</span><br><span class="line">    moduleNameMapper: &#123;</span><br><span class="line">        &apos;^common(.*)$&apos;: &apos;&lt;rootDir&gt;/src/static/js/util/common$1&apos;,</span><br><span class="line">        &apos;^widget(.*)$&apos;: &apos;&lt;rootDir&gt;/src/static/js/util/widget$1&apos;,</span><br><span class="line">        &apos;\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$&apos;: &apos;&lt;rootDir&gt;/__mocks__/fileMock.js&apos;,</span><br><span class="line">        &apos;\\.(css|less|scss)$&apos;: &apos;&lt;rootDir&gt;/__mocks__/styleMock.js&apos;,</span><br><span class="line">        &apos;(^|./)css&apos;: &apos;&lt;rootDir&gt;/__mocks__/styleMock.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    snapshotSerializers: [&apos;enzyme-to-json/serializer&apos;],</span><br><span class="line">    coveragePathIgnorePatterns: [],</span><br><span class="line">    testPathIgnorePatterns: [&apos;/node_modules/&apos;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">beforeAll(() =&gt; console.log(&apos;1 - beforeAll&apos;)); // 当前文件中所有测试执行前触发，只执行一次</span><br><span class="line">afterAll(() =&gt; console.log(&apos;1 - afterAll&apos;)); // 当前文件中所有测试执行结束后触发，只执行一次</span><br><span class="line">beforeEach(() =&gt; console.log(&apos;1 - beforeEach&apos;)); // 当前文件中每个测试执行前都会触发；</span><br><span class="line">afterEach(() =&gt; console.log(&apos;1 - afterEach&apos;)); // 当前文件中每个测试结束后都会触发</span><br><span class="line"></span><br><span class="line">// describe的作用就是对某一块进行分组，每一块属于不同的作用域，当上面的四个周期函数放到块中时，就只适用于该describe块内的测试。</span><br><span class="line">describe(&apos;dir1 test&apos;, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">   test(&apos;1+1 = &apos;,() =&gt; &#123;</span><br><span class="line">      expect(sum(1,2)).toBe(3);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   test(&apos;测试对象是否相等&apos;,()=&gt;&#123;</span><br><span class="line">      const data = &#123;one: 1&#125;;</span><br><span class="line">      data[&apos;two&apos;] = 2;</span><br><span class="line">      expect(data).toEqual(&#123;one: 1,two: 2 &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   test(&apos;快照测试 &apos;, () =&gt; &#123;</span><br><span class="line">      const user = &#123;</span><br><span class="line">         // createdAt: new Date(),</span><br><span class="line">         // id: Math.floor(Math.random() * 20),</span><br><span class="line">         id: &apos;234&apos;,</span><br><span class="line">         name: &apos;LeBron James&apos;</span><br><span class="line">      &#125;;</span><br><span class="line">      expect(user).toMatchSnapshot();   // 生成快照</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>Matchers ，也叫断言库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expect(&#123;a:1&#125;).toBe(&#123;a:1&#125;)			//判断两个对象是否相等</span><br><span class="line">expect(1).not.toBe(2)			    //判断不等</span><br><span class="line">expect(n).toBeNull(); 			    //判断是否为null</span><br><span class="line">expect(n).toBeUndefined(); 			//判断是否为undefined</span><br><span class="line">expect(n).toBeDefined(); 		    //判断结果与toBeUndefined相反</span><br><span class="line">expect(n).toBeTruthy(); 		    //判断结果为true</span><br><span class="line">expect(n).toBeFalsy(); 			    //判断结果为false</span><br><span class="line">expect(value).toBeGreaterThan(3); 	//大于3</span><br><span class="line">expect(value).toBeGreaterThanOrEqual(3.5); 	 //大于等于3.5</span><br><span class="line">expect(value).toBeLessThan(5); 				//小于5</span><br><span class="line">expect(value).toBeLessThanOrEqual(4.5); 	 //小于等于4.5</span><br><span class="line">expect(value).toBeCloseTo(0.3); 		    // 浮点数判断相等</span><br><span class="line">expect(&apos;Christoph&apos;).toMatch(/stop/); 		//正则表达式判断</span><br><span class="line">expect([&apos;one&apos;,&apos;two&apos;]).toContain(&apos;one&apos;); 	//数组中是否含有某个元素</span><br></pre></td></tr></table></figure>

<p>Jest为我们提供了<code>expect</code>函数用来包装被测试的方法并返回一个对象，该对象中包含一系列的匹配器来让我们更方便的进行断言， </p>
<h4 id="快照测试"><a href="#快照测试" class="headerlink" title="快照测试"></a>快照测试</h4><p>快照测试是 Jest 内置了一种很有用的测试方式。快照测试可以用于保证界面不出现异常变化。 快照测试的基本原理是，渲染页面然后截图，将得到到截图与样本图片进行对比，以此来检查渲染是否符合预期。 两张图片对比不一致时，也有可能是预期发生了变化，这时就需要更新样本图片。</p>
<p>实际测试中，并不是必须对比图片，样本也可以是一份状态描述的字符串，这时只要对比序列化的字符串便可以验证渲染逻辑。</p>
<p>实际使用时，并不需要手工编写快照样本，Jest 可以在首次执行时可以自动生成快照样本，当测试代码有变化时，还可以通过 jest -u 来更新样本。 生成的样本会放在测试文件同级目录下的 <strong>snapshots</strong> 文件夹中。 </p>
<h2 id="enzyme"><a href="#enzyme" class="headerlink" title="enzyme"></a>enzyme</h2><p>Enzyme是由Airbnb开源的一个React的JavaScript测试工具，使React组件的输出更加容易推断。Enzyme的API和jQuery操作DOM一样灵活易用。</p>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i --save-dev enzyme@3.9.0  enzyme-adapter-react-16.2@1.5.2</span><br></pre></td></tr></table></figure>

<h4 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h4><p>enzyme支持三种方式的渲染： <em>浅渲染</em> (<code>shallow</code>)、<em>完全渲染</em>  (<code>mount</code>)、<em>静态渲染</em>  (<code>render</code>)</p>
<p><strong>shallow</strong>：浅渲染，是对官方的Shallow Renderer的封装。将组件渲染成虚拟DOM对象，只会渲染第一层，子组件将不会被渲染出来，因而效率非常高。不需要DOM环境， 并可以使用jQuery的方式访问组件的信息；</p>
<p><strong>render</strong>：静态渲染，它将React组件渲染成静态的HTML字符串，然后使用Cheerio这个库解析这段字符串，并返回一个Cheerio的实例对象，可以用来分析组件的html结构。</p>
<p><strong>mount</strong>：完全渲染，它将组件渲染加载成一个真实的DOM节点，用来测试DOM API的交互和组件的生命周期，用到了jsdom来模拟浏览器环境。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- render采用的是第三方库Cheerio的渲染，渲染结果是普通的html结构</span><br><span class="line"></span><br><span class="line">- shallow和mount对组件的渲染结果不是html的dom树，而是react树 。shallow和mount的结果是个被封装的ReactWrapper，可以进行多种操作，譬如find()、parents()、children()等选择器进行元素查找；state()、props()进行数据查找，setState()、setprops()操作数据；simulate()模拟事件触发</span><br><span class="line"></span><br><span class="line">- shallow只渲染当前组件，只能对当前组件做断言；mount会渲染当前组件以及所有子组件，对所有子组件也可以做上述操作。一般交互测试都会关心到子组件，此时使用mount。但是mount耗时更长，内存占用的更多，如果没必要操作和断言子组件，可以使用shallow</span><br></pre></td></tr></table></figure>

<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>Shallow Rendering： 适用于当没有和DOM互动，不涉及子组件时 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; shallow &#125; from &apos;enzyme&apos;;</span><br><span class="line"></span><br><span class="line">const wrapper = shallow(&lt;MyComponent /&gt;);</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<p> Full Rendering</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; mount &#125; from &apos;enzyme&apos;;</span><br><span class="line"></span><br><span class="line">const wrapper = mount(&lt;MyComponent /&gt;);</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<p>Static Rendering</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; render &#125; from &apos;enzyme&apos;;</span><br><span class="line"></span><br><span class="line">const wrapper = render(&lt;MyComponent /&gt;);</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>

<p>常用的enzyme api方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.get(index)：返回指定位置的子组件的DOM节点</span><br><span class="line">.at(index)：返回指定位置的子组件</span><br><span class="line">.text()：返回当前组件的文本内容</span><br><span class="line">.html()：返回当前组件的HTML代码形式</span><br><span class="line">.props()：返回根组件的所有属性</span><br><span class="line">.prop(key)：返回根组件的指定属性</span><br><span class="line">.state([key])：返回根组件的状态</span><br></pre></td></tr></table></figure>

<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>Enzymetest.js文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">export default class EnzymeTest extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            title: &apos;标题1&apos;,</span><br><span class="line">        &#125;;</span><br><span class="line">        this.handleClick = this.handleClick.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        this.setState(&#123; title: &apos;标题2&apos;&#125;);</span><br><span class="line">        console.log(&apos;执行.&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; name &#125; = this.props;</span><br><span class="line">        const &#123; title &#125; = this.state;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.handleClick&#125;&gt;&#123;name&#125;&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enzyme.test.js文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import Enzyme,&#123; mount &#125; from &apos;enzyme&apos;</span><br><span class="line">import Adapter from &apos;enzyme-adapter-react-16&apos;</span><br><span class="line">import EnzymeTest from &apos;../EnzymeTest&apos;;</span><br><span class="line"></span><br><span class="line">Enzyme.configure(&#123; adapter: new Adapter() &#125;);</span><br><span class="line"></span><br><span class="line">describe(&apos;Enzyme shallow&apos;, ()=&gt; &#123;</span><br><span class="line"></span><br><span class="line">    test(&apos;Example component&apos;, ()=&gt; &#123;</span><br><span class="line"></span><br><span class="line">        const name=&apos;确定&apos;;</span><br><span class="line">        const wapper = mount( &lt;EnzymeTest name=&#123;name&#125; /&gt;);</span><br><span class="line"></span><br><span class="line">        expect(wapper.find(&apos;h1&apos;).text()).toBe(&apos;标题1&apos;);</span><br><span class="line">        expect(wapper.find(&apos;button&apos;).text()).toBe(&apos;确定&apos;);</span><br><span class="line"></span><br><span class="line">        wapper.find(&apos;button&apos;).simulate(&apos;click&apos;);</span><br><span class="line">        expect(wapper.find(&apos;h1&apos;).text()).toBe(&apos;标题2&apos;);</span><br><span class="line"></span><br><span class="line">        wapper.setProps(&#123; name: &apos;取消&apos; &#125;);</span><br><span class="line">        expect(wapper.find(&apos;button&apos;).text()).toBe(&apos;取消&apos;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>jest</tag>
        <tag>单元测试</tag>
        <tag>enzyme</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客速搭</title>
    <url>/10/30/hexo/</url>
    <content><![CDATA[<h3 id="hexo介绍"><a href="#hexo介绍" class="headerlink" title="hexo介绍"></a>hexo介绍</h3><p>使用hexo搭建博客十分的简单，适用于想写博客但并不想花费过多时间用于搭建博客的同学~</p>
<p>主页： <strong><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></strong> </p>
<p>主页的内容已经很详细了，这里只记录几点使用中发现的注意点。</p>
<a id="more"></a>

<ul>
<li><p><strong>文件目录说明（这里只简单说明，详细介绍请移步官网~~）</strong>：</p>
<p>_config.yml ：配置文件 </p>
<p>public ：生成的静态文件，这个目录最终会发布到服务器 </p>
<p>source ：编写的markdown文件，_drafts草稿文件，_posts发布的文章 </p>
<p>themes ：博客的模板 </p>
</li>
<li><p><strong>编写博客</strong></p>
<p>官方提供的是命令的方式:  <code>hexo new [layout] &lt;title&gt;</code>,实际上，还有另一种方式可以节约我们的时间。将我们已经编写好的markdown文件直接放在_posts文件夹下，并且在最上方加上注释即可。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 30分钟搭建博客并发布到github</span><br><span class="line">date: 2019-10-29 17:49:54</span><br><span class="line">tags: </span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>本地运行</strong></p>
<p>打开cmd进入到项目路径下，运行命令hexo server即可本地运行,默认访问地址为：<strong><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></strong>。还有另一种运行方式，了解node的同学都知道，package.json文件中可以配置脚本，其实项目初始化后已经帮助我们配置好了，打开package.json文件即可看到如下内容，所以使用命令： <strong>npm run server</strong>  ，一样可以启动本地运行。同时，他提供的有build 、clean、deploy等命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;hexo generate&quot;,</span><br><span class="line">    &quot;clean&quot;: &quot;hexo clean&quot;,</span><br><span class="line">    &quot;deploy&quot;: &quot;hexo deploy&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;hexo server&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发布流程</strong></p>
<p><strong>第一步</strong>：建仓库。</p>
<p>在自己的github仓库中创建一个仓库(repository )，注意仓库名称，比如我的账号是lmAsm,那么仓库的名称必须是lmAsm.github.io，同时，仓库权限设置为public。</p>
<p><strong>第二步</strong>：配置SSH。</p>
<p>这个就不解释啦，相信大家都会哒~</p>
<p><strong>第三步</strong>：修改项目的配置文件。</p>
<p>打开项目根目录，如我的是：<code>D:\hexo</code>，然后用编辑器打开<code>_config.yml</code>配置文件，文件最后可以看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure>

<p>修改成如下并保存:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p><strong>第四步</strong>：部署</p>
<p>打开命令行，执行命令<code>hexo deploy</code>或者命令<code>npm run deploy</code>。 到这里就大功告成啦！</p>
<p>若是遇到异常可以执行下面命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>如果出现下面的这个异常: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>

<p>输入以下命令，然后重新执行刚刚的两条命令 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>这时候如果弹出一个对话框，输入在github上面的用户名和密码即可 。</p>
<p>这时候我们就可以在浏览器输入<a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io</a> 打开 查看效果啦。</p>
</li>
<li><p><strong>常见问题</strong></p>
<p>1、执行deploy命令了，但是代码没有上传？</p>
<p><strong>解决方案：</strong></p>
<p>先执行<code>hexo generate</code>命令，生成静态文件，再执行hexo deploy上传，上传是只会上传public中生成的文件 .</p>
</li>
</ul>
<p><strong>本文会持续更新记录优化博客遇到的一系列问题以及小技巧，欢迎关注，互放友链~~</strong></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>优化</tag>
      </tags>
  </entry>
</search>
